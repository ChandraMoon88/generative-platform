/**
 * Code Generation Engine
 * Generates application code from synthesized models
 */

import { logger } from '../utils/logger';

interface Entity {
  id: string;
  name: string;
  displayName: string;
  properties: EntityProperty[];
  relationships: EntityRelationship[];
  operations: string[];
}

interface EntityProperty {
  name: string;
  type: string;
  required: boolean;
  defaultValue?: unknown;
}

interface EntityRelationship {
  type: 'one-to-one' | 'one-to-many' | 'many-to-many';
  targetEntity: string;
  foreignKey?: string;
}

interface Screen {
  id: string;
  name: string;
  path: string;
  type: 'list' | 'detail' | 'form' | 'dashboard' | 'custom';
  components: UIComponent[];
  actions: string[];
  entity?: string;
}

interface UIComponent {
  id: string;
  type: string;
  props: Record<string, unknown>;
  children?: UIComponent[];
}

interface ApplicationModel {
  id: string;
  name: string;
  entities: Entity[];
  screens: Screen[];
  workflows: unknown[];
  navigation: { type: string; items: unknown[] };
}

interface GeneratedFile {
  path: string;
  content: string;
  type: 'component' | 'type' | 'store' | 'api' | 'page' | 'config';
}

/**
 * Code Generation Engine
 * Transforms application models into runnable code
 */
export class CodeGenerationEngine {
  private outputDir: string;
  
  constructor(outputDir: string = 'generated') {
    this.outputDir = outputDir;
  }
  
  /**
   * Generate all code from an application model
   */
  public generate(model: ApplicationModel): GeneratedFile[] {
    const files: GeneratedFile[] = [];
    
    logger.info(`Generating code for model: ${model.name}`);
    
    // Generate types for each entity
    files.push(...this.generateEntityTypes(model.entities));
    
    // Generate Zustand store
    files.push(this.generateStore(model.entities));
    
    // Generate API routes
    files.push(...this.generateApiRoutes(model.entities));
    
    // Generate pages
    files.push(...this.generatePages(model.screens, model.entities));
    
    // Generate components
    files.push(...this.generateComponents(model.screens));
    
    // Generate navigation
    files.push(this.generateNavigation(model.navigation));
    
    logger.info(`Generated ${files.length} files`);
    
    return files;
  }
  
  /**
   * Generate TypeScript types for entities
   */
  private generateEntityTypes(entities: Entity[]): GeneratedFile[] {
    const files: GeneratedFile[] = [];
    
    for (const entity of entities) {
      const content = this.generateEntityTypeFile(entity);
      files.push({
        path: `${this.outputDir}/types/${entity.name}.ts`,
        content,
        type: 'type',
      });
    }
    
    // Generate index file
    const indexContent = entities
      .map(e => `export * from './${e.name}';`)
      .join('\n');
    
    files.push({
      path: `${this.outputDir}/types/index.ts`,
      content: indexContent,
      type: 'type',
    });
    
    return files;
  }
  
  /**
   * Generate a single entity type file
   */
  private generateEntityTypeFile(entity: Entity): string {
    const properties = entity.properties
      .map(p => `  ${p.name}${p.required ? '' : '?'}: ${this.tsType(p.type)};`)
      .join('\n');
    
    const createType = entity.properties
      .filter(p => p.name !== 'id' && p.name !== 'createdAt' && p.name !== 'updatedAt')
      .map(p => `  ${p.name}${p.required ? '' : '?'}: ${this.tsType(p.type)};`)
      .join('\n');
    
    return `/**
 * ${entity.displayName} Entity
 * Auto-generated by Generative Platform
 */

export interface ${this.pascalCase(entity.name)} {
${properties}
}

export interface Create${this.pascalCase(entity.name)} {
${createType}
}

export interface Update${this.pascalCase(entity.name)} extends Partial<Create${this.pascalCase(entity.name)}> {
  id: string;
}

export type ${this.pascalCase(entity.name)}ListItem = Pick<${this.pascalCase(entity.name)}, 'id' | 'createdAt'${entity.properties.slice(0, 3).map(p => ` | '${p.name}'`).join('')}>;
`;
  }
  
  /**
   * Generate Zustand store for all entities
   */
  private generateStore(entities: Entity[]): GeneratedFile {
    const imports = entities
      .map(e => `import type { ${this.pascalCase(e.name)}, Create${this.pascalCase(e.name)}, Update${this.pascalCase(e.name)} } from '../types/${e.name}';`)
      .join('\n');
    
    const stateProperties = entities
      .map(e => `  ${this.camelCase(e.name)}s: ${this.pascalCase(e.name)}[];`)
      .join('\n');
    
    const actions = entities
      .map(e => this.generateEntityActions(e))
      .join('\n\n');
    
    const initialState = entities
      .map(e => `    ${this.camelCase(e.name)}s: [],`)
      .join('\n');
    
    const content = `/**
 * Application Store
 * Auto-generated by Generative Platform
 */

import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';
${imports}

interface AppState {
${stateProperties}
  isLoading: boolean;
  error: string | null;
}

interface AppActions {
${entities.map(e => this.generateActionTypes(e)).join('\n')}
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
  reset: () => void;
}

type AppStore = AppState & AppActions;

const initialState: AppState = {
${initialState}
  isLoading: false,
  error: null,
};

export const useAppStore = create<AppStore>()(
  devtools(
    persist(
      (set, get) => ({
        ...initialState,
${actions}
        setLoading: (loading) => set({ isLoading: loading }),
        setError: (error) => set({ error }),
        reset: () => set(initialState),
      }),
      { name: 'app-store' }
    )
  )
);
`;
    
    return {
      path: `${this.outputDir}/store/appStore.ts`,
      content,
      type: 'store',
    };
  }
  
  /**
   * Generate CRUD actions for an entity
   */
  private generateEntityActions(entity: Entity): string {
    const name = this.camelCase(entity.name);
    const Name = this.pascalCase(entity.name);
    const names = `${name}s`;
    
    return `        // ${entity.displayName} Actions
        add${Name}: (item: Create${Name}) => {
          const newItem: ${Name} = {
            ...item,
            id: crypto.randomUUID(),
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
          } as ${Name};
          set((state) => ({ ${names}: [...state.${names}, newItem] }));
        },
        update${Name}: (update: Update${Name}) => {
          set((state) => ({
            ${names}: state.${names}.map((item) =>
              item.id === update.id
                ? { ...item, ...update, updatedAt: new Date().toISOString() }
                : item
            ),
          }));
        },
        delete${Name}: (id: string) => {
          set((state) => ({
            ${names}: state.${names}.filter((item) => item.id !== id),
          }));
        },
        get${Name}: (id: string) => {
          return get().${names}.find((item) => item.id === id);
        },`;
  }
  
  /**
   * Generate action type declarations
   */
  private generateActionTypes(entity: Entity): string {
    const name = this.camelCase(entity.name);
    const Name = this.pascalCase(entity.name);
    
    return `  add${Name}: (item: Create${Name}) => void;
  update${Name}: (update: Update${Name}) => void;
  delete${Name}: (id: string) => void;
  get${Name}: (id: string) => ${Name} | undefined;`;
  }
  
  /**
   * Generate API routes for entities
   */
  private generateApiRoutes(entities: Entity[]): GeneratedFile[] {
    const files: GeneratedFile[] = [];
    
    for (const entity of entities) {
      const content = this.generateApiRouteFile(entity);
      files.push({
        path: `${this.outputDir}/app/api/${entity.name}/route.ts`,
        content,
        type: 'api',
      });
      
      // Dynamic route
      const dynamicContent = this.generateDynamicApiRoute(entity);
      files.push({
        path: `${this.outputDir}/app/api/${entity.name}/[id]/route.ts`,
        content: dynamicContent,
        type: 'api',
      });
    }
    
    return files;
  }
  
  /**
   * Generate main API route file
   */
  private generateApiRouteFile(entity: Entity): string {
    const Name = this.pascalCase(entity.name);
    const names = `${this.camelCase(entity.name)}s`;
    
    return `/**
 * ${entity.displayName} API Routes
 * Auto-generated by Generative Platform
 */

import { NextRequest, NextResponse } from 'next/server';
import type { ${Name}, Create${Name} } from '@/types/${entity.name}';

// In-memory storage (replace with database)
let ${names}: ${Name}[] = [];

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const limit = parseInt(searchParams.get('limit') || '50');
  const offset = parseInt(searchParams.get('offset') || '0');
  
  const items = ${names}.slice(offset, offset + limit);
  
  return NextResponse.json({
    items,
    total: ${names}.length,
    limit,
    offset,
  });
}

export async function POST(request: NextRequest) {
  try {
    const body: Create${Name} = await request.json();
    
    const newItem: ${Name} = {
      ...body,
      id: crypto.randomUUID(),
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    } as ${Name};
    
    ${names}.push(newItem);
    
    return NextResponse.json(newItem, { status: 201 });
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to create ${entity.displayName.toLowerCase()}' },
      { status: 400 }
    );
  }
}
`;
  }
  
  /**
   * Generate dynamic API route
   */
  private generateDynamicApiRoute(entity: Entity): string {
    const Name = this.pascalCase(entity.name);
    const names = `${this.camelCase(entity.name)}s`;
    
    return `/**
 * ${entity.displayName} Dynamic API Routes
 * Auto-generated by Generative Platform
 */

import { NextRequest, NextResponse } from 'next/server';

// Reference to in-memory storage from parent route
// In production, use database

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  // Implement database lookup
  return NextResponse.json({ id: params.id, message: 'Implement database lookup' });
}

export async function PUT(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const body = await request.json();
    // Implement database update
    return NextResponse.json({ id: params.id, ...body });
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to update ${entity.displayName.toLowerCase()}' },
      { status: 400 }
    );
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  // Implement database delete
  return new NextResponse(null, { status: 204 });
}
`;
  }
  
  /**
   * Generate page files
   */
  private generatePages(screens: Screen[], entities: Entity[]): GeneratedFile[] {
    const files: GeneratedFile[] = [];
    
    for (const screen of screens) {
      const entity = entities.find(e => e.name === screen.entity);
      let content: string;
      
      switch (screen.type) {
        case 'list':
          content = this.generateListPage(screen, entity);
          break;
        case 'form':
          content = this.generateFormPage(screen, entity);
          break;
        case 'detail':
          content = this.generateDetailPage(screen, entity);
          break;
        case 'dashboard':
          content = this.generateDashboardPage(screen);
          break;
        default:
          content = this.generateCustomPage(screen);
      }
      
      files.push({
        path: `${this.outputDir}/app${screen.path}/page.tsx`,
        content,
        type: 'page',
      });
    }
    
    return files;
  }
  
  /**
   * Generate list page
   */
  private generateListPage(screen: Screen, entity?: Entity): string {
    const Name = entity ? this.pascalCase(entity.name) : 'Item';
    const names = entity ? `${this.camelCase(entity.name)}s` : 'items';
    
    return `'use client';

/**
 * ${screen.name} Page
 * Auto-generated by Generative Platform
 */

import { useState } from 'react';
import { useAppStore } from '@/store/appStore';
import Link from 'next/link';

export default function ${this.pascalCase(screen.name.replace(/\s/g, ''))}Page() {
  const { ${names}, delete${Name} } = useAppStore();
  const [search, setSearch] = useState('');
  const [sortField, setSortField] = useState<string>('createdAt');
  const [sortDir, setSortDir] = useState<'asc' | 'desc'>('desc');
  
  const filtered = ${names}
    .filter(item => JSON.stringify(item).toLowerCase().includes(search.toLowerCase()))
    .sort((a, b) => {
      const aVal = a[sortField as keyof typeof a];
      const bVal = b[sortField as keyof typeof b];
      if (sortDir === 'asc') return aVal > bVal ? 1 : -1;
      return aVal < bVal ? 1 : -1;
    });
  
  return (
    <div className="p-6">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">${screen.name}</h1>
        <Link
          href="${screen.path}/new"
          className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700"
        >
          Add New
        </Link>
      </div>
      
      <div className="mb-4">
        <input
          type="text"
          placeholder="Search..."
          value={search}
          onChange={(e) => setSearch(e.target.value)}
          className="w-full p-2 border rounded"
        />
      </div>
      
      <div className="bg-white rounded-lg shadow overflow-hidden">
        <table className="min-w-full divide-y divide-gray-200">
          <thead className="bg-gray-50">
            <tr>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">ID</th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Created</th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Actions</th>
            </tr>
          </thead>
          <tbody className="divide-y divide-gray-200">
            {filtered.map((item) => (
              <tr key={item.id}>
                <td className="px-6 py-4 whitespace-nowrap">{item.id.slice(0, 8)}</td>
                <td className="px-6 py-4 whitespace-nowrap">{new Date(item.createdAt).toLocaleDateString()}</td>
                <td className="px-6 py-4 whitespace-nowrap">
                  <Link href={\`${screen.path}/\${item.id}\`} className="text-blue-600 hover:underline mr-4">
                    View
                  </Link>
                  <button
                    onClick={() => delete${Name}(item.id)}
                    className="text-red-600 hover:underline"
                  >
                    Delete
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
        
        {filtered.length === 0 && (
          <div className="text-center py-8 text-gray-500">
            No items found
          </div>
        )}
      </div>
    </div>
  );
}
`;
  }
  
  /**
   * Generate form page
   */
  private generateFormPage(screen: Screen, entity?: Entity): string {
    const Name = entity ? this.pascalCase(entity.name) : 'Item';
    const properties = entity?.properties.filter(p => 
      !['id', 'createdAt', 'updatedAt'].includes(p.name)
    ) || [];
    
    const formFields = properties.map(p => `
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            ${this.toDisplayName(p.name)}${p.required ? ' *' : ''}
          </label>
          <input
            type="${this.inputType(p.type)}"
            name="${p.name}"
            required={${p.required}}
            className="w-full p-2 border rounded focus:ring-2 focus:ring-blue-500"
          />
        </div>`).join('\n');
    
    return `'use client';

/**
 * ${screen.name} Page
 * Auto-generated by Generative Platform
 */

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { useAppStore } from '@/store/appStore';

export default function ${this.pascalCase(screen.name.replace(/\s/g, ''))}Page() {
  const router = useRouter();
  const { add${Name} } = useAppStore();
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setIsSubmitting(true);
    
    const formData = new FormData(e.currentTarget);
    const data = Object.fromEntries(formData.entries());
    
    try {
      add${Name}(data);
      router.push('${screen.path.replace('/new', '').replace('/edit', '')}');
    } catch (error) {
      console.error('Failed to save:', error);
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    <div className="p-6 max-w-2xl mx-auto">
      <h1 className="text-2xl font-bold mb-6">${screen.name}</h1>
      
      <form onSubmit={handleSubmit} className="space-y-4">
${formFields}
        
        <div className="flex gap-4 pt-4">
          <button
            type="submit"
            disabled={isSubmitting}
            className="bg-blue-600 text-white px-6 py-2 rounded hover:bg-blue-700 disabled:opacity-50"
          >
            {isSubmitting ? 'Saving...' : 'Save'}
          </button>
          <button
            type="button"
            onClick={() => router.back()}
            className="border border-gray-300 px-6 py-2 rounded hover:bg-gray-50"
          >
            Cancel
          </button>
        </div>
      </form>
    </div>
  );
}
`;
  }
  
  /**
   * Generate detail page
   */
  private generateDetailPage(screen: Screen, entity?: Entity): string {
    const Name = entity ? this.pascalCase(entity.name) : 'Item';
    
    return `'use client';

/**
 * ${screen.name} Detail Page
 * Auto-generated by Generative Platform
 */

import { useParams, useRouter } from 'next/navigation';
import { useAppStore } from '@/store/appStore';
import Link from 'next/link';

export default function ${this.pascalCase(screen.name.replace(/\s/g, ''))}DetailPage() {
  const params = useParams();
  const router = useRouter();
  const { get${Name}, delete${Name} } = useAppStore();
  
  const item = get${Name}(params.id as string);
  
  if (!item) {
    return (
      <div className="p-6 text-center">
        <h1 className="text-xl text-gray-500">Item not found</h1>
        <button onClick={() => router.back()} className="mt-4 text-blue-600 hover:underline">
          Go Back
        </button>
      </div>
    );
  }
  
  const handleDelete = () => {
    if (confirm('Are you sure you want to delete this item?')) {
      delete${Name}(item.id);
      router.push('${screen.path.replace(/\/\[.*\]/, '')}');
    }
  };
  
  return (
    <div className="p-6 max-w-2xl mx-auto">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">Details</h1>
        <div className="space-x-2">
          <Link
            href={\`${screen.path.replace(/\/\[.*\]/, '')}/\${item.id}/edit\`}
            className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700"
          >
            Edit
          </Link>
          <button
            onClick={handleDelete}
            className="bg-red-600 text-white px-4 py-2 rounded hover:bg-red-700"
          >
            Delete
          </button>
        </div>
      </div>
      
      <div className="bg-white rounded-lg shadow p-6">
        <dl className="space-y-4">
          {Object.entries(item).map(([key, value]) => (
            <div key={key}>
              <dt className="text-sm font-medium text-gray-500">{key}</dt>
              <dd className="mt-1 text-gray-900">{String(value)}</dd>
            </div>
          ))}
        </dl>
      </div>
    </div>
  );
}
`;
  }
  
  /**
   * Generate dashboard page
   */
  private generateDashboardPage(screen: Screen): string {
    return `'use client';

/**
 * ${screen.name} Page
 * Auto-generated by Generative Platform
 */

import { useAppStore } from '@/store/appStore';

export default function ${this.pascalCase(screen.name.replace(/\s/g, ''))}Page() {
  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold mb-6">${screen.name}</h1>
      
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
        {/* Stats cards - customize based on your needs */}
        <div className="bg-white rounded-lg shadow p-6">
          <h3 className="text-sm font-medium text-gray-500">Total Items</h3>
          <p className="mt-2 text-3xl font-bold">0</p>
        </div>
        
        <div className="bg-white rounded-lg shadow p-6">
          <h3 className="text-sm font-medium text-gray-500">Active</h3>
          <p className="mt-2 text-3xl font-bold text-green-600">0</p>
        </div>
        
        <div className="bg-white rounded-lg shadow p-6">
          <h3 className="text-sm font-medium text-gray-500">Pending</h3>
          <p className="mt-2 text-3xl font-bold text-yellow-600">0</p>
        </div>
        
        <div className="bg-white rounded-lg shadow p-6">
          <h3 className="text-sm font-medium text-gray-500">Completed</h3>
          <p className="mt-2 text-3xl font-bold text-blue-600">0</p>
        </div>
      </div>
    </div>
  );
}
`;
  }
  
  /**
   * Generate custom page
   */
  private generateCustomPage(screen: Screen): string {
    return `'use client';

/**
 * ${screen.name} Page
 * Auto-generated by Generative Platform
 */

export default function ${this.pascalCase(screen.name.replace(/\s/g, ''))}Page() {
  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold mb-6">${screen.name}</h1>
      <p className="text-gray-500">Custom page content goes here.</p>
    </div>
  );
}
`;
  }
  
  /**
   * Generate components
   */
  private generateComponents(screens: Screen[]): GeneratedFile[] {
    const componentTypes = new Set<string>();
    
    for (const screen of screens) {
      for (const component of screen.components) {
        componentTypes.add(component.type);
      }
    }
    
    const files: GeneratedFile[] = [];
    
    for (const type of componentTypes) {
      const content = this.generateComponent(type);
      files.push({
        path: `${this.outputDir}/components/${type}.tsx`,
        content,
        type: 'component',
      });
    }
    
    return files;
  }
  
  /**
   * Generate a reusable component
   */
  private generateComponent(type: string): string {
    // Common component templates
    const templates: Record<string, string> = {
      DataTable: `'use client';

interface Column<T> {
  key: keyof T;
  label: string;
  sortable?: boolean;
}

interface DataTableProps<T> {
  data: T[];
  columns: Column<T>[];
  onSort?: (key: keyof T) => void;
  onRowClick?: (item: T) => void;
}

export function DataTable<T extends { id: string }>({
  data,
  columns,
  onSort,
  onRowClick,
}: DataTableProps<T>) {
  return (
    <table className="min-w-full divide-y divide-gray-200">
      <thead className="bg-gray-50">
        <tr>
          {columns.map((col) => (
            <th
              key={String(col.key)}
              onClick={() => col.sortable && onSort?.(col.key)}
              className={\`px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase \${col.sortable ? 'cursor-pointer hover:bg-gray-100' : ''}\`}
            >
              {col.label}
            </th>
          ))}
        </tr>
      </thead>
      <tbody className="divide-y divide-gray-200">
        {data.map((item) => (
          <tr
            key={item.id}
            onClick={() => onRowClick?.(item)}
            className={onRowClick ? 'cursor-pointer hover:bg-gray-50' : ''}
          >
            {columns.map((col) => (
              <td key={String(col.key)} className="px-6 py-4 whitespace-nowrap">
                {String(item[col.key])}
              </td>
            ))}
          </tr>
        ))}
      </tbody>
    </table>
  );
}
`,
      FilterPanel: `'use client';

interface FilterOption {
  value: string;
  label: string;
}

interface FilterPanelProps {
  filters: {
    name: string;
    label: string;
    options: FilterOption[];
  }[];
  values: Record<string, string>;
  onChange: (name: string, value: string) => void;
  onClear: () => void;
}

export function FilterPanel({ filters, values, onChange, onClear }: FilterPanelProps) {
  return (
    <div className="bg-gray-50 p-4 rounded-lg mb-4 flex flex-wrap gap-4">
      {filters.map((filter) => (
        <select
          key={filter.name}
          value={values[filter.name] || ''}
          onChange={(e) => onChange(filter.name, e.target.value)}
          className="border rounded p-2"
        >
          <option value="">{filter.label}</option>
          {filter.options.map((opt) => (
            <option key={opt.value} value={opt.value}>
              {opt.label}
            </option>
          ))}
        </select>
      ))}
      <button onClick={onClear} className="text-gray-600 hover:text-gray-800">
        Clear Filters
      </button>
    </div>
  );
}
`,
      SearchInput: `'use client';

interface SearchInputProps {
  value: string;
  onChange: (value: string) => void;
  placeholder?: string;
}

export function SearchInput({ value, onChange, placeholder = 'Search...' }: SearchInputProps) {
  return (
    <div className="relative">
      <input
        type="text"
        value={value}
        onChange={(e) => onChange(e.target.value)}
        placeholder={placeholder}
        className="w-full pl-10 pr-4 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
      />
      <svg
        className="absolute left-3 top-1/2 transform -translate-y-1/2 h-5 w-5 text-gray-400"
        fill="none"
        stroke="currentColor"
        viewBox="0 0 24 24"
      >
        <path
          strokeLinecap="round"
          strokeLinejoin="round"
          strokeWidth={2}
          d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
        />
      </svg>
    </div>
  );
}
`,
      Form: `'use client';

interface FormField {
  name: string;
  label: string;
  type: string;
  required?: boolean;
  options?: { value: string; label: string }[];
}

interface FormProps {
  fields: FormField[];
  onSubmit: (data: Record<string, unknown>) => void;
  initialValues?: Record<string, unknown>;
  submitLabel?: string;
}

export function Form({ fields, onSubmit, initialValues = {}, submitLabel = 'Submit' }: FormProps) {
  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const formData = new FormData(e.currentTarget);
    const data = Object.fromEntries(formData.entries());
    onSubmit(data);
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      {fields.map((field) => (
        <div key={field.name}>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            {field.label} {field.required && '*'}
          </label>
          {field.type === 'select' ? (
            <select
              name={field.name}
              defaultValue={String(initialValues[field.name] || '')}
              required={field.required}
              className="w-full p-2 border rounded"
            >
              <option value="">Select...</option>
              {field.options?.map((opt) => (
                <option key={opt.value} value={opt.value}>
                  {opt.label}
                </option>
              ))}
            </select>
          ) : (
            <input
              type={field.type}
              name={field.name}
              defaultValue={String(initialValues[field.name] || '')}
              required={field.required}
              className="w-full p-2 border rounded"
            />
          )}
        </div>
      ))}
      <button
        type="submit"
        className="bg-blue-600 text-white px-6 py-2 rounded hover:bg-blue-700"
      >
        {submitLabel}
      </button>
    </form>
  );
}
`,
    };
    
    return templates[type] || `'use client';

// ${type} Component
// Auto-generated - customize as needed

interface ${type}Props {
  // Add props here
}

export function ${type}({}: ${type}Props) {
  return (
    <div>
      {/* ${type} implementation */}
    </div>
  );
}
`;
  }
  
  /**
   * Generate navigation component
   */
  private generateNavigation(navigation: { type: string; items: unknown[] }): GeneratedFile {
    const items = navigation.items as { label: string; path: string; icon?: string }[];
    
    const content = `'use client';

/**
 * Navigation Component
 * Auto-generated by Generative Platform
 */

import Link from 'next/link';
import { usePathname } from 'next/navigation';

const navItems = ${JSON.stringify(items, null, 2)};

export function Navigation() {
  const pathname = usePathname();
  
  return (
    <nav className="bg-gray-800 text-white w-64 min-h-screen p-4">
      <div className="text-xl font-bold mb-8 px-4">App Name</div>
      <ul className="space-y-2">
        {navItems.map((item) => {
          const isActive = pathname === item.path || pathname.startsWith(item.path + '/');
          return (
            <li key={item.path}>
              <Link
                href={item.path}
                className={\`block px-4 py-2 rounded-lg transition-colors \${
                  isActive
                    ? 'bg-gray-700 text-white'
                    : 'text-gray-300 hover:bg-gray-700 hover:text-white'
                }\`}
              >
                {item.label}
              </Link>
            </li>
          );
        })}
      </ul>
    </nav>
  );
}
`;
    
    return {
      path: `${this.outputDir}/components/Navigation.tsx`,
      content,
      type: 'component',
    };
  }
  
  // Utility methods
  
  private tsType(type: string): string {
    const typeMap: Record<string, string> = {
      string: 'string',
      text: 'string',
      number: 'number',
      integer: 'number',
      float: 'number',
      currency: 'number',
      boolean: 'boolean',
      datetime: 'string',
      date: 'string',
      time: 'string',
      email: 'string',
      phone: 'string',
      url: 'string',
      image: 'string',
    };
    return typeMap[type] || 'unknown';
  }
  
  private inputType(type: string): string {
    const typeMap: Record<string, string> = {
      string: 'text',
      text: 'textarea',
      number: 'number',
      integer: 'number',
      float: 'number',
      currency: 'number',
      boolean: 'checkbox',
      datetime: 'datetime-local',
      date: 'date',
      time: 'time',
      email: 'email',
      phone: 'tel',
      url: 'url',
    };
    return typeMap[type] || 'text';
  }
  
  private pascalCase(str: string): string {
    return str.replace(/(^|[^a-zA-Z0-9])([a-z])/g, (_, sep, c) => c.toUpperCase());
  }
  
  private camelCase(str: string): string {
    const pascal = this.pascalCase(str);
    return pascal.charAt(0).toLowerCase() + pascal.slice(1);
  }
  
  private toDisplayName(str: string): string {
    return str
      .replace(/([a-z])([A-Z])/g, '$1 $2')
      .replace(/[_-]/g, ' ')
      .replace(/\b\w/g, c => c.toUpperCase());
  }
}

// Singleton instance
let generatorInstance: CodeGenerationEngine | null = null;

export function getCodeGenerator(outputDir?: string): CodeGenerationEngine {
  if (!generatorInstance) {
    generatorInstance = new CodeGenerationEngine(outputDir);
  }
  return generatorInstance;
}
